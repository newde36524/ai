package main

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"errors"
	"flag"
	"fmt"
	"io"
	"net/http"
	"net/textproto"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

var (
	longQuest bool
	reset     bool
)

func init() {
	flag.BoolVar(&longQuest, "l", false, "进入上下文对话模式")
	flag.BoolVar(&reset, "r", false, "重置配置")
	flag.Parse()
}

func main() {
	ex, _ := os.Executable()
	config := NewConfig(filepath.Join(filepath.Dir(ex), "ai_config.json"))
	cli := NewClient()
	if !reset {
		config.Load()
	}
	cli.SetConfig(config)
	if err := cli.CheckUserInfo(); err != nil {
		fmt.Println(err)
		return
	}
	if err := cli.Login(); err != nil {
		fmt.Println(err)
		return
	}
	defer cli.Clear()
	if err := cli.CheckConfig(); err != nil {
		fmt.Println(err)
		return
	}
	if err := config.Save(); err != nil {
		fmt.Println(err)
		return
	}
	args := Filter(os.Args[1:], func(item string) bool {
		return item != "-l" && item != "-r"
	})
	if longQuest {
		fmt.Println("进入上下文对话模式")
		_ = cli.LongChat(args...)
	}
	if len(os.Args) > 1 {
		_, _ = cli.Completion("", strings.Join(args, " "), os.Stdout)
		fmt.Println("")
	} else {
		fmt.Println("例子: ai hi 或者 ai -l 进入上下文对话模式")
	}
}

type Client struct {
	client *http.Client
	config *Config
}

func NewClient() *Client {
	return &Client{
		client: &http.Client{},
	}
}

func (c *Client) SetConfig(config *Config) {
	c.config = config
}

func (c *Client) Login() error {
	if c.config.LastLogin == time.Now().Format(time.DateOnly) {
		return nil
	}
	type AutoGenerated struct {
		Msg  string `json:"msg"`
		Code string `json:"code"`
	}
	urlPath := "https://www.scnet.cn/ac/api/auth/loginDesktopClient.action"
	vs := url.Values{
		"username":  []string{c.config.UserName},
		"password":  []string{encrypt(c.config.Password)},
		"encrypted": []string{"true"},
		"ph":        []string{"1"},
	}
	req, err := http.NewRequest(http.MethodPost, urlPath, strings.NewReader(vs.Encode()))
	if err != nil {
		return err
	}
	req.Header.Add("content-type", "application/x-www-form-urlencoded")
	req.Header.Add("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
	req.Header.Add("priority", "u=1, i")
	resp, err := c.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	bs, _ := io.ReadAll(resp.Body)
	var data AutoGenerated
	_ = json.Unmarshal(bs, &data)
	if data.Code != "0" {
		return errors.New("账号不存在或密码错误")
	}
	var cookies []string
	for _, v := range resp.Header["Set-Cookie"] {
		cookies = append(cookies, v[:strings.Index(v, ";")])
	}
	c.config.Cookie = strings.Join(append(cookies, fmt.Sprintf("SKIP_SESSION_UPDATE=%d", time.Now().AddDate(0, 0, -5).Unix())), ";")
	c.config.LastLogin = time.Now().Format(time.DateOnly)
	return err
}

// https://www.scnet.cn/ui/chatbot/
func (c *Client) Completion(conversationId, content string, w io.Writer) (string, error) {
	type AutoGenerated struct {
		ConversationID string `json:"conversationId"`
		MsgID          string `json:"msgId"`
		ReplyMsgID     string `json:"replyMsgId"`
		Content        string `json:"content"`
		ContentType    string `json:"contentType"`
		ReplyType      string `json:"replyType"`
		CreateTime     string `json:"createTime"`
	}
	urlPath := "https://www.scnet.cn/acx/chatbot/v1/chat/completion"
	reqData, _ := json.Marshal(map[string]interface{}{
		"conversationId": conversationId,
		"content":        content,
		"thinkingEnable": true,
		"onlineEnable":   true,
		"modelId":        c.config.GetActiveModelId(),
		"textFile":       []struct{}{},
		"imageFile":      []struct{}{},
		"clusterId":      "",
	})
	req, err := http.NewRequest(http.MethodPost, urlPath, bytes.NewReader(reqData))
	if err != nil {
		return "", err
	}
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
	req.Header.Add("Priority", "u=1, i")
	req.Header.Add("Cookie", c.config.Cookie)
	resp, err := c.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	var wg sync.WaitGroup
	wg.Add(1)
	queue := NewQueue(w, &wg)
	go queue.Task()
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		text := strings.Trim(strings.Trim(scanner.Text(), "data:"), "\n")
		if strings.Contains(text, "[done]") {
			continue
		}
		var data AutoGenerated
		_ = json.Unmarshal([]byte(text), &data)
		if len(conversationId) == 0 && len(data.ConversationID) > 0 {
			conversationId = data.ConversationID
		}
		for _, v := range strings.Split(data.Content, "") {
			queue.Enqueue(v)
		}
	}
	queue.Close()
	wg.Wait()
	return conversationId, scanner.Err()
}

func (c *Client) LongChat(msg ...string) error {
	var conversationId string
	for {
		fmt.Println("---------------------------")
		var (
			text string
			err  error
		)
		if len(msg) > 0 {
			text = strings.Join(msg, " ")
			fmt.Println(text)
			msg = nil
		} else {
			text, err = ReadText()
			if err != nil {
				return err
			}
		}
		conversationId, err = c.Completion(conversationId, text, os.Stdout)
		if err != nil {
			return err
		}
		fmt.Println("")
	}
}

func (c *Client) Clear() error {
	conversationIds, err := c.List()
	if err != nil {
		return err
	}
	for _, conversationId := range conversationIds {
		if err := c.Delete(conversationId); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) List() (conversationIds []string, err error) {
	type AutoGenerated struct {
		Code string `json:"code"`
		Msg  string `json:"msg"`
		Data struct {
			Records []struct {
				ID         string      `json:"id"`
				Title      string      `json:"title"`
				CreateTime string      `json:"createTime"`
				TaskStatus interface{} `json:"taskStatus"`
			} `json:"records"`
			End int `json:"end"`
		} `json:"data"`
	}
	urlPath := "https://www.scnet.cn/acx/chatbot/conversation/list?page=1&size=30&source=chat"
	req, err := http.NewRequest(http.MethodGet, urlPath, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
	req.Header.Add("Priority", "u=1, i")
	req.Header.Add("Cookie", c.config.Cookie)
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bs, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data AutoGenerated
	if err := json.Unmarshal(bs, &data); err != nil {
		return nil, err
	}
	for _, v := range data.Data.Records {
		conversationIds = append(conversationIds, v.ID)
	}
	return
}

func (c *Client) Delete(conversationId string) error {
	urlPath := fmt.Sprintf("https://www.scnet.cn/acx/chatbot/conversation/%s", conversationId)
	req, err := http.NewRequest(http.MethodDelete, urlPath, nil)
	if err != nil {
		return err
	}
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
	req.Header.Add("Priority", "u=1, i")
	req.Header.Add("Cookie", c.config.Cookie)
	resp, err := c.client.Do(req)
	if err != nil {
		return err
	}
	resp.Body.Close()
	return nil
}

func (c *Client) ModelList() (map[int]string, error) {
	type AutoGenerated struct {
		Code string `json:"code"`
		Msg  string `json:"msg"`
		Data struct {
			RecommendQuestion []string `json:"recommendQuestion"`
			RecommendAD       []struct {
				Logo string `json:"logo"`
				Name string `json:"name"`
				URL  string `json:"url"`
			} `json:"recommendAD"`
			ModelList []struct {
				ID             int    `json:"id"`
				Name           string `json:"name"`
				Logo           string `json:"logo"`
				OnlineEnable   bool   `json:"onlineEnable"`
				ThinkingEnable bool   `json:"thinkingEnable"`
				Description    string `json:"description"`
				ModelType      string `json:"modelType"`
			} `json:"modelList"`
			OnlineSearchEnable        bool   `json:"onlineSearchEnable"`
			AnonUserOnlineSearchCount int    `json:"anonUserOnlineSearchCount"`
			APIDocumentURL            string `json:"apiDocumentUrl"`
			LoginEnable               bool   `json:"loginEnable"`
			FileUploadEnable          bool   `json:"fileUploadEnable"`
			RelatedQuestionEnable     bool   `json:"relatedQuestionEnable"`
		} `json:"data"`
	}
	urlPath := "https://www.scnet.cn/acx/chatbot/config/list"
	req, err := http.NewRequest(http.MethodGet, urlPath, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36")
	req.Header.Add("Priority", "u=1, i")
	req.Header.Add("Cookie", c.config.Cookie)
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bs, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data AutoGenerated
	if err := json.Unmarshal(bs, &data); err != nil {
		return nil, err
	}
	resull := make(map[int]string)
	for _, v := range data.Data.ModelList {
		resull[v.ID] = v.Name
	}
	return resull, nil
}

func (c *Client) CheckUserInfo() error {
	if len(c.config.UserName) == 0 || len(c.config.Password) == 0 {
		fmt.Println("当前尚未设置用户信息，如果没有账号密码请前往指定地址注册: https://www.scnet.cn/ui/chatbot/")
		c.config.UserName = ""
		c.config.Password = ""
	}
	if len(c.config.UserName) == 0 {
		prefix := "请输入用户名: "
		fmt.Print(prefix)
		text, err := ReadText()
		if err != nil {
			return err
		}
		c.config.UserName = strings.TrimSpace(strings.TrimPrefix(text, prefix))
	}
	if len(c.config.Password) == 0 {
		prefix := "请输入密码: "
		fmt.Print(prefix)
		text, err := ReadText()
		if err != nil {
			return err
		}
		c.config.Password = strings.TrimSpace(strings.TrimPrefix(text, prefix))
	}
	return nil
}

func (c *Client) CheckConfig() error {
	if !c.config.IsEmpty() {
		return nil
	}
	modelList, err := c.ModelList()
	if err != nil {
		return err
	}
	c.config.Models = nil
	for k, v := range modelList {
		c.config.Models = append(c.config.Models, &struct {
			ModelId   int    `json:"modelId"`
			ModelName string `json:"modelName"`
			Active    bool   `json:"active"`
		}{
			ModelId:   k,
			ModelName: v,
		})
	}
	mp := make(map[int]*struct {
		ModelId   int    `json:"modelId"`
		ModelName string `json:"modelName"`
		Active    bool   `json:"active"`
	})
	for _, v := range c.config.Models {
		fmt.Printf("%d: %s\n", v.ModelId, v.ModelName)
		mp[v.ModelId] = v
	}
	prefix := "请通过数字选择模型(推荐 8): "
	for {
		fmt.Print(prefix)
		text, err := ReadText()
		if err != nil {
			return err
		}
		modelId, err := strconv.Atoi(strings.TrimSpace(strings.TrimPrefix(text, prefix)))
		if err != nil || mp[modelId] == nil {
			prefix = "不存在该模型，请重新选择: "
			continue
		}
		mp[modelId].Active = true
		break
	}
	return nil
}

type Config struct {
	Models []*struct {
		ModelId   int    `json:"modelId"`
		ModelName string `json:"modelName"`
		Active    bool   `json:"active"`
	} `json:"models"`
	fullName  string
	UserName  string `json:"username"`
	Password  string `json:"password"`
	Cookie    string `json:"cookie"`
	LastLogin string `json:"lastLogin"`
}

func NewConfig(fullName string) *Config {
	return &Config{
		fullName: fullName,
	}
}

func (c *Config) GetActiveModelId() int {
	for _, v := range c.Models {
		if v.Active {
			return v.ModelId
		}
	}
	return 0
}

func (c *Config) IsEmpty() bool {
	for _, v := range c.Models {
		if v.Active {
			return false
		}
	}
	return true
}

func (c *Config) Save() error {
	_, err := os.Stat(c.fullName)
	if err != nil {
		if os.IsNotExist(err) {
			file, err := os.Create(c.fullName)
			if err != nil {
				return err
			}
			defer file.Close()
			encoder := json.NewEncoder(file)
			encoder.SetEscapeHTML(false)
			return encoder.Encode(c)
		}
		return err
	}
	if err := os.Remove(c.fullName); err != nil {
		return err
	}
	fs, err := os.Create(c.fullName)
	if err != nil {
		return err
	}
	defer fs.Close()
	bs, _ := json.Marshal(c)
	_, err = fs.Write(bs)
	return err
}

func (c *Config) Load() error {
	bs, err := os.ReadFile(c.fullName)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}
	return json.Unmarshal(bs, c)
}

func encrypt(password string) string {
	// 浏览器端公钥
	const pubPEM = `-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALaXEnbjI6fjy+t9W9AiO/KS0q+b/OZF
S+7ykinLbiriUx9P8BcuuHnVbXNiZp5jW70eVGBtX4DhGUPzJa1YT/8CAwEAAQ==
-----END PUBLIC KEY-----`

	cipherHex, err := rsaEncryptPassword(pubPEM, password)
	if err != nil {
		panic(err)
	}
	bs, err := hex.DecodeString(cipherHex)
	if err != nil {
		panic(err)
	}
	return base64.StdEncoding.EncodeToString(bs)
}

func rsaEncryptPassword(pubPEM, plain string) (string, error) {
	block, _ := pem.Decode([]byte(pubPEM))
	if block == nil {
		return "", errors.New("invalid pem")
	}
	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return "", err
	}
	rsaPub := pub.(*rsa.PublicKey)

	// PKCS#1 v1.5 填充加密
	cipher, err := rsa.EncryptPKCS1v15(rand.Reader, rsaPub, []byte(plain))
	if err != nil {
		return "", err
	}

	// 转成 16 进制字符串（大写，带前导 0）
	return hex.EncodeToString(cipher), nil
}

func Filter(data []string, callback func(string) bool) []string {
	var result []string
	for _, v := range data {
		if callback(v) {
			result = append(result, v)
		}
	}
	return result
}

func ReadText() (string, error) {
	rd := textproto.NewReader(bufio.NewReader(os.Stdin))
	return rd.ReadLine()
}

type Queue struct {
	data chan string
	w    io.Writer
	flag bool
	wg   *sync.WaitGroup
}

func NewQueue(w io.Writer, wg *sync.WaitGroup) *Queue {
	return &Queue{
		data: make(chan string),
		w:    w,
		wg:   wg,
	}
}

func (q *Queue) Enqueue(data string) {
	if data == "【" {
		q.flag = true
	}
	if q.flag {
		if data == "】" {
			q.flag = false
		}
		return
	}
	q.data <- data
}

func (q *Queue) Close() {
	close(q.data)
}

func (q *Queue) Task() {
	defer q.wg.Done()
	for {
		v, ok := <-q.data
		if !ok {
			return
		}
		q.w.Write([]byte(v))
	}
}
